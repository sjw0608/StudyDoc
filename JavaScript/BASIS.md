

## 变量提升机制

### 条件判断下的变量提升

```js
if(true){
   console.log(fn) // =》 函数本身：当条件成立，进入到判断体中（在ES6中他是一个块级作用域）第一件事情不是代码执行，而是类似于变量提升一样，先把FN声明和定义了，也就是判断体中代码执行之前，FN就已经赋值了
   function fn(){ console.log('ok') }
}
```

### 变量声明重名问题

- 带VAR和FUNCTION关键字声明相同的名字，这种也算事重名了
- 关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）【不管是变量提升，还是代码执行皆是如此】

```js
fn() // 4
function fn(){ console.log(1) }
fn() // 4
function fn(){ console.log(2) }
fn() // 4
var fn = 100 // => 带VAR的在提升阶段只把声明处理了，赋值操作没有处理，所以在代码执行阶段需要完成赋值
fn() // TypeError: fn is not a function
function fn(){ console.log(3) }
fn()
function fn(){ console.log(4) }
fn()
```

### ES6不存在变量提升机制

> 在ES6中基于 LET/CONST 等方式创建变量或函数，不存在变量提升机制
>
> 切断了全局变量和WINDOW属性的映射机制（不管用什么方式在当前作用域下声明了变量，再次使用LET创建都会报错）
>
> 在相同作用域中，基于LET不能声明相同的变量虽然没有变量提升机制，但是在当前作用域代码自上而下执行之前，浏览器会做一个重复性检测（语法检测）：自上而下查找当前作用域下所有变量，一旦发现有重复的，直接抛出异常，代码也不会在执行了（虽然没有吧变量提前声明定义，但是浏览器已经记住了当前作用域下有哪些变量）。

```js
let a = 10,
    b = 10;
let fn = ()=>{
  // console.log(a,b); // 直接报错
  let a = b = 20;
  console.log(a,b);
}
fn();
console.log(a,b);
```

```js
var a = 12 
if(true){
  console.log(a) // Uncaught ReferenceError: a is not defined
  let a = 13 // => 基于LET创建变量，会把大部分{}当做一个私有的块级作用域（类似于函数的私有作用域），在这里也是重新检测语法规范，看一下是否是基于新语法创建的变量，如果是按照新语法规范来解析
}
```

### 暂时性死区

```js
// console.log(typeof a) // undefined 在原有浏览器渲染机制下，基于typeof等逻辑运算符检测一个未被声明过的变量，不会报错，返回 undefined

console.log(typeof a) // Uncaught ReferenceError: a is not defined
let a
```

### 区分私有变量和全局变量

```js
var a = 12,b=13,c=14;
function fn(a){
  // 在私有做域中只有以下两种情况是私有变量
  // A：声明过的变量（带VAR/FUNCTION）
  // B：形参也是私有变量
  // 剩下的都不是自己私有的变量，都需要基于作用域链的机制向上查找
  console.log(a,b,c) // 12 undefined 14
  var b = c = a = 20
  console.log(a,b,c) // 20 20 20 
}
fn(a)
console.log(a,b,c) // 12 13 20 
```

```js
var ary = [12,13]
function fn(ary){
  // 形参赋值 ary = 全局ary的堆空间地址
  console.log(ary) // [12,13]
  ary[0] = 100 // => 全局ary: [100,13]
  ary = [100] // => 新创建了一个队空间存储 函数私有ary:[100]
  ary[0] = 0
  console.log(ary) // 私有ary : [0]
}
fn(ary)
console.log(ary)// [100,13] 
```

### 查找上级作用域

```js
// 当前函数执行，形成一个私有作用域A，A的上级作用域是谁，和他在那执行没有关系，和他在那创建的有关系，在哪创建，它的上级作用域就是谁
var a = 12
function fn(){
  console.log(a)
}
function sum(){
  var a = 120
  fn()
}
sum() // 12

function fn(){
  // arguments:实参集合
  // arguments.callee:函数本身FN
  // arguments.callee.caller:当前函数在哪执行的，caller就是谁（记录的是它执行的宿主环境），在全局下执行caller的结果是NULL
  console.log(arguments)
}
function sum(){
  var a = 120
  fn()
}
sum()
// 练习
var n = 10
function fn(){
  var n = 20
  function f(){
    n++
    console.log(n) 
  }
  f()
  return f
}
let x = fn() // 21
x() // 22
x() // 23
console.log(n) // 10
```

## 闭包及堆栈内存释放

> JS中内存分为堆内存和栈内存
>
> 堆内存：存储引用数据类型值（对象：键值对 函数：代码字符串）
>
> 栈内存：提供JS代码执行的环境和存储基本类型值
>
> 【堆内存释放】
>
> 让所有引用堆内存空间地址的变量赋值为null即可（没有变量占用这个堆内存，浏览器在空闲的时候会把他释放掉）
>
> 【栈内存释放】
>
> 一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也都会释放掉），但是也有特殊不销毁的情况：
>
> - 1.函数执行完成，当前形成的栈内存中，某些内容被栈内存意外的变量占用了，此时栈内存不能释放（一旦释放外面找不到原有的内存了）
>
> - 2.全局栈内存只有在页面关闭的时候才会被释放掉
>
>   如果当前栈内存没有被释放，那么之前在栈内存中存储的基本值也不会被释放，能够一直保存下来

```js
// 练习
var i =1
function fn(i){
  return function (n){
    console.log(n+(++i))
  }
}
var f = fn(2) 
f(3) // 6
fn(5)(6) // 12
fn(7)(8) // 16
f(4) // 8
```

### 闭包

> 函数执行形成一个私有的作用域，保护里面私有变量不受外界的干扰，这种保护机制称之为 ‘闭包’
> 市面上的开发者认为的闭包是：形成一个不销毁的私有作用域（私有栈内存）才是闭包
>
> 闭包项目实战应用
>
> 真实项目中为了保证JS的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）
>
> 1. 闭包具有"保护"作用：保护私有变量不受外界的干扰
>
> 2. 闭包具有"保存"作用：形成不销毁的栈内存，把一些值保存下来，方便后面的调取使用

```js
for(var i =0;i<tabList.length;i++){
  tabList[i].onclick = function (){console.log(i)}
  // 执行方法，形成私有的栈内存，遇到变量I，不是私有变量，向上一级作用域查找（上级作用域WINDOW）
  // 所有的事件绑定都是异步编程（同步编程：一件事一件事的做，当前这件事没完成，下一个任务不能处理。/ 异步编程：当前这件事情没有彻底完成，不在等待，继续执行下面的任务），绑定事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已结束（让全局的I等于循环最后的结果3）
}
```

## 面向对象编程（OOP）

### 单例模式（Singleton Patter）

```js
// 1. 表现形式
var obj = {
  xxx:xxx
  ...
}
// 在单例设计模型中，OBJ不仅仅是对象名，他被称为“命名空间【NameSpace】”，把描述事物的属性存放到命名空间，多个命名空间是独立分开的，互不冲突

// 2. 作用：把描述同一件事物的属性和特征进行“分组、归类”（存储在同一个堆内存空间中），因此避免了全局变量之间的冲突和污染

// 3. 单例设计模式命名的由来： 每一个命名空间都是JS中Object这个内置基类的实例，而实例之间是相互独立互不干扰的，所以我们称它为“单例：单独的实例”
```

#### 高级单例模式

> 1. 在给命名空间赋值的时候，不是直接赋值一个对象，而是先执行匿名函数，形成一个私有作用域AA（不销毁的栈内存），在AA中创建一个堆内存，把堆内存地址赋值给命名空间
> 2. 这种模式的好处：我们完全可以在AA中创造很多内容（变量OR函数），哪些需要外面调取使用的，我们暴露到返回的对象中（模块化实现的一种思想）

```js
var nameSpace = (function(){
  var n = 12;
  function fn(){
    // todo...
  }
  function sum(){
  }
  return {
    fn:fn,
    sum:sum
  }
})();
```

```js
var n = 2
var obj = {
  n:3,
  fn:(function(n){
    n*=2
    this.n+=2 // 当前this为window
    var n = 5
    return function(m){
      this.n*=2
      console.log(m+(++n))
    }
  })(n)
}
var fn = obj.fn
fn(3) // 9
obj.fn(3) // 10
console.log(n,obj.n) // 8 6
```

> THIS指向
>
> 1. 给当前元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的THIS是当前操作的元素对象
> 2. 普通函数执行，函数中的THIS取决于执行的主体，谁执行的，THIS就是谁（执行主体：方法执行，看方法名前面是否有“点”，有的话，点前面是谁HTIS就是谁，没有THIS就是WINDOW）
> 3. 自执行函数执行，方法中THIS是window

#### 模块化开发

> 1. 团队协作开发的时候，会把 产品按照功能版块进行划分，每一个功能版块有专人负责开发
> 2. 把各个版块之间公用的部门进行提取封装，后期在想实现这些功能，直接的调取引用即可（模块封装）

### 工厂模式（Factory Pattern）

> 1. 把实现相同功能的代码进行“封装”，以此来实现”批量生产“想要实现这个功能，我们只需要执行函数即可
> 2. ”低耦合高内聚“：减少页面中的冗余代码，提高代码的重复使用率

## 函数

函数有三种角色(三种角色间没有什么必然关系)：

- 1.普通函数
  - 堆栈内存释放
  - 作用域链

- 2.类
  - `prototype` 原型
  - `__proto__` 原型链
  - 实例
- 3.普通对象
  - 和普通的一个OBJ没什么区别，就是对键值对的增删改查

