# 正则RegExp

## 什么是正则

> 是一个用来处理字符串的规则
>
> - 正则只能用来处理字符串
> - 处理一般包含两方面
>   - 验证当前字符串是否符合某个规范“正则匹配”
>   - 把一个字符串中符合规则的字符获取到“正则捕获”
>
> 每一个正则都是由“元字符”、”修饰符“两部分组成

```js
// 1. 创建正则的两种方式
let reg1 = /^\d+$/g; // 字面量方式
let reg2 = new RegExp("^\\d+$","g") // 构造函数方式
// 2. 正则两个斜杠之间包起来的都是“元字符”，斜杠后面出现的都是“修饰符”
```

## 常用的修饰符

- `i` : ignoreCase 忽略大小写
- `m`：multiline 多行匹配
- `g`：global 全局匹配

## 常用的元字符

- 特殊元字符
  - `\d`  0～9之间的一个数字 
  - `\D` 非0～9之间的任意字符
  - `\w` “数字、字母、下划线”中的任意一个
  - `\W` 除“数字、字母、下划线”中的任意一个
  - `\s` 匹配任意一个空白字符串（包括\t制表符【TAB键四个空格】）
  - `\b` 匹配边界符
  - `\n` 匹配一个换行符
  - `\` 转义字符（把一个普通字符转义为特殊的字符，例如：`\d`;把有特殊含义的转换为普通意思,例如：`\.`此处的点就不是任意字符，而是一个小数点）
  - `^` 以某个元字符开头
  - `$` 以某个元字符结尾
  - `x|y` x或者y中的任意一个
  - `[xyz]` x或者y或者z中的任意一个 ,`[^xyz]` 除了x、y、z以外的任意字符
  - `[a-z] ` 获取a-z中的任意一个字符,` [^a-z]` 除了a-z的任意字符
  - `()` 正则分组
  - `(?:)` 当前分组只匹配不捕获
  - `(?=)` 向上预查
  - `(?!)` 负向预查
- 量词元字符：让其左边的元字符出现多少次
  - `*` ：出现领导多次
  - `?` : 出现零到一次
  - `+` ：出现一到多次
  - `{n}`：出现n次
  - `{n,}`：出现N到多次
  - `{n,m}`：出现N到M次
- 普通元字符
  - 只要在正则中出现的元字符（在基于字面量方式创建），除了特殊和量词意义以外的，都是普通元字符

### `[]`的作用

> 中括号的一些细节
>
> - 在中括号中出现的元字符一般都是代表本身含义的
> - 中括号中出现的两位数，不是两位数字，而是两个数字中的任意一个
>   - `/^[12-65]$/` 这个正则的意思是 1或者 2～6或者5

```js
// 年龄：18～65之间
let reg = /^((1[8,9])|([2-5]\d)|(6[0-5]))$/
// 匹配 "[object AAA]"
let reg = /^\[object .+\]$/
```

### `()`的作用

> - 改变的默认的优先级
> - 分组捕获
> - 分组引用

## 常用正则表达式

### 有效数字

- 正数、负数、零
- 小数、正数

```js
// 规则
// 1. 可出现 +/-号，可以没有，也可以有一个
// 2. 正数 0 12 9:一位或者多位数字，一位0～9，多位数字不能以0开头
// 3. 小数部分：可能有可能没有，有小数点后面至少要跟一位数字
let reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/
```

### 电话号码

- 11位数字
- 以1开头

```js
let reg = /^1\d{10}$/
```

### 中文姓名

- 中文汉字  [\u4E00-\u9FA5]

```js
let reg = /^[\u4E00-\u9FA5]{2,}(·[\u4E00-\u9FA5]{2,})?$/
```

### 邮箱

- 第一部分：数字、字母、下划线、-、. ，但是 - 和 . 不能作为开头，不能连续出现 - 或者 .
- 第二部分：域名的名字只能是“数字和字母”

```js
let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/
let reg = /^\w+([-.\w+])*@[A-Za-z0-9]+([-.][A-Za-z0-9]+)*(\.[A-Za-z0-9])+$/
```

## 正则基础知识

### 正则捕获

> 把一个字符串中和正则匹配的部分获取到
>
> 【正则】
>
> - exec：基于EXEC可以实现正则的捕获
>   - 如果当前正则和字符串不匹配，捕获的结果是NULL
>   - 如果匹配，捕获的结果是一个数组
>     - 0：大正则捕获的内容
>     - index：正则捕获的起始索引
>     - input：原始操作的字符串
>   - 执行一次EXEC只能捕获到第一个和正则匹配的内容，其余匹配的内容还没有捕获到=》"正则的捕获有懒惰性"
> - test
>   - 基于TEST进行匹配的时候，如果设置了G，TEST匹配也相当于捕获，修改了 `lastIndex` 的值
>
> 【字符串】
>
> - replace：字符串替换
>   - 用正则和字符串进行匹配，匹配几次就替换几次，每一次都是把当前“大正则”匹配的结果用第二个传递的字符串替换掉了
> - split
> - match

#### 正则捕获的懒惰性

> 只能捕获到第一个匹配的内容，剩余的默认捕获不到
>
> 主要原因是每次捕获的时候` RegExp.lastIndex`不变导致的懒惰性，即使手动修改了 `lastIndex`，也没什么用；解决正则懒惰性，我们需要添加全局修饰符`g`（这个是唯一的方案，而且不加G不管用什么办法捕获，也都不能把全部匹配的捕获到）
>
> `RegExp.lastIndex` ：正则捕获时候，下一次在字符串中开始查找的索引

```js
let str = 'song1996jiang06wei08'
let reg = /\d+/g 

/**
* Match 的原理
* str: 我们要捕获的字符串
*/
RegExp.prototype.myExecAll = function(str){
  // this:reg 当前操作的正则
  // 为了防止出现死循环，我们检测一下正则是否加G，没有加G只把第一次捕获的结果返回即可
  if(!this.global){
    return this.exec(str)
  }
  let result = [], valAry = this.exec(str)
  while(valAry){
    result.push(valAry[0]) // 把每一次正则捕获到的结果第一项（具体捕获的内容）存粗到容器中
    valAry = this.exec(str)
  }
  return result
}
```

#### 正则捕获的贪婪和分组捕获

> 分组捕获：在正则捕获的时候，如果正则中存在分组，捕获的时候不仅仅把大正则匹配到的字符捕获到（数组第一项），而且把小分组匹配的内容也单独抽取出来（数组中的第二项开始就是小分组捕获的内容），而 `?:` 是用来阻止分组捕获内容的“只匹配不捕获”
>
> 正则捕获还具备贪婪性：每一次匹配捕获的时候，总是捕获到正则匹配中最长的内容，例如：‘2’，符合 `\d+` '2018' 也符合 `\d+`，但是捕获的是最长的内容‘2018’

```js
let str = 'song1996jiang06wei08'
let reg = /\d+?/g // 把问号放到量词元字符后面，代表的就不是出现零次或者一次了，而且取消捕获的贪婪性
```

##### `?` 在正则中的作用

- 量词元字符：出现零次或者一次
  - `/-?/` 让减号出现一次或者不出现
- 取消贪婪性
  - `/\d+?/` 捕获的时候只捕获最短匹配的内容
- `?:` 只匹配不捕获
- `?=` 正向预查
- `?!` 负向预查

